---
title: "R Training Documentation"
output:
  pdf_document: default
  html_document: default
  word_document: default
date: "2023-10-17"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
```


# Introduction

### Source files, directories, important functions in R

The working directory is the folder your R session 'lives in.' In general, it is good practice to have your working directory set to the folder which houses the open file. getwd() displays the current working directory of the session. You can set the working directory to the path of the desired folder by using setwd(...). 

If ever you are confused about a package or function in RStudio, typing '?' in front of the argument will display the documentation for that function in your session. For information on VectorSurv specific functions, please see the documentation below.

In the code, a '#' tells the compiler to ignore that line. This can be used to add comments or to intentionally ignore code. 

```{r}

#To get current directory
getwd()

#To get information on function in R documentation
?getwd()


#'VS_functions.R' should be in the same directory as the .rmd 
#'files which access its functions, you can set the working directory 

#Path to folder on my computer: "C:\Users\Christina\Desktop\R-tutorial" 
#this path will be slightly different for you depending on the file location.

#Set below to the location of the downloaded files on your machine, 
#make sure to change the direction of the slash from "\" to "/" to indicate opening of the folder. 

setwd("/Users/Christina/Desktop/R-tutorial")


```

There is one .R file. The .R file is a source file that contains all of the functions you will need to run the .RMarkdown files. You do not need to touch the source file. The .RMarkdown files are pre-coded sample reports that you can customize to suit your needs. 

```{r}
#loads relevant packages and functions
source("source_functions.R")

```




# Retrieving Data

**getArthroCollections(...)**

*Description*

getArthroCollections(...) obtains collections data on a year range (start_year, end_year) and agency_id. It prompts the user for their Gateway username and password before retrieving the associated data. If you do not enter an agency id, you will retrieve all data you have access to in VectorSurv. Adding agency id is helpful for users who have access to multiple agencies, such as state agencies.  Agency id is the number associated with your agency through VectorSurv. You can only retrieve data from agencies linked to your Gateway account. See getToken() below for retrieving a list of your available agencies. 

*Usage*

getArthroCollections(start_year, end_year, agency_id)

*Arguments*

- start_year: Beginning of year range 
- end_year: End of year range
- agency_id: Agency ID number, if left blank, the default will return data for all agencies linked to you account. The majority of users are linked to one agency  


```{r}
#Example
collections = getArthroCollections(2022,2023, 55)
```


**getPools(...)**

*Description*

getPools(...) similar to getArthroCollections() obtains pools on a year range (start_year, end_year) and agency_id. It prompts the user for their Gateway username and password before retrieving the associated data. getPools() retrieve data for both mosquito and tick pools. If you do not enter an agency id, you will retrieve all data you have access to in VectorSurv. Adding agency id is helpful for users who have access to multiple agencies, such as state agencies.  Agency id is the number associated with your agency through VectorSurv. You can only retrieve data from agencies linked to your Gateway account. See getToken() below for retrieving a list of your available agencies. 

*Usage*

getPools(start_year, end_year, agency_id)

*Arguments*

- start_year: Beginning of year range 
- end_year: End of year range
- agency_id: Agency ID number 

```{r}
#Example
pools = getPools(2022,2023, 55)
```

**getToken()**

*Description*

getToken() is called by both getArthroCollections() and getPools() to prompt users for their Gateway credentials. If credentials are accepted, the function returns a user token and a list of agencies available to the user. This function should only be called if you wish to see the list of agencies and associated codes you have access to.

*Usage*

getToken()

*Arguments*

```{r, results='hide'}

getToken()

```


## Write Data to file

You can save retrieved data as a .csv file in your current directory using write.csv().
That same data can be retrieved using read.csv(). Writing data to a .csv can make the rendering process more efficient when generating reports in R. We recommend that you write the data pulled from our API into a csv and then load that data when generating reports.



 read.csv(...)

```{r}
#creates a file named "collections_18_23.csv" in your current directory
 write.csv(x = collections, file = "collections_18_23.csv")

#loads collections data 
collections = read.csv("collections_18_23.csv")

```


## Basic subseting, filtering, grouping, pivoting



Data can be subset to contain columns of interest. Sub-setting can also be used to reorder the columns in a dataframe.Do not subset collections or pools data before inputting them into VectorSurv calculator functions to avoid losing essential columns. It is recommended to subset after calculations are complete and before inputting into a table generator. **Remember, subseting, filtering, grouping and summarizing will not change the value of the data unless it is reassigned to the same variable name.** We recomment creating a new variable for processed data.  

### Subseting 

```{r}
#Subset using column names or index number

colnames(collections) #displays column names and associated index


#Subseting by name
head(collections[c("collection_date","species_display_name","num_count")])

#by index
head(collections[c(3,23,17)])

#to save a subset
collections_subset = collections[c(3,23,17)]
```

### Filtering and subsetting in dplyr 

Dplyr is a powerful package for filtering and sub-setting data. It follows logic similar to SQL queries.

For more information on data manipulation using dplyr [Click Here](https://datacarpentry.org/dc_zurich/R-ecology/04-dplyr.html)

Dplyr utilizes the pipe operator '%>%' to send data into functions. The head() function returns the first few rows of data, specifying head(1) tells the software to return only the first row for viewing purposes. Remove head() to see all the data or reassign the data to a new variable.

```{r}
#Subsetting columns with dplyr 'select'
collections %>% 
  select(collection_date,species_display_name,num_count)%>%
  head()


```
Below are more examples for filtering data.

```{r}

#filtering with dplyr 'filter'
collections_pip = collections %>% 
  filter(species_display_name=="Cx pipiens") 

#filtering multiple arguments using '%in%'
collections_pip_tar = collections %>% 
  filter(species_display_name %in% c("Cx pipiens", "Cx tarsalis"),
         site %in% c(119819,102832)) #filters site codes
  
```

### Group by 

In addition to filtering and sub-setting, data can be group by variables and summarized.

```{r}
#groups by species and collection date and sums the number counted

collections %>% 
  group_by(collection_date, species_display_name) %>%
  summarise(sum_count = sum(num_count, na.rm=T))%>%
  head()


#groups by species and collection date and takes the average the number counted

collections %>% 
  group_by(collection_date, species_display_name) %>%
  summarise(avg_count = mean(num_count, na.rm=T))%>%
  head()
```

### Pivoting

Data can be manipulated into long and wide (spread sheet) forms using pivot_wider and pivot_longer. By default data from the API is in long form. Here we pivot on species and sex condition names using num_count as values. The end result is data with num_count values in the columns named species_sex. For more on pivoting see ??pivot_longer and ??pivot_wider.

```{r}

collections_wide = pivot_wider(collections,
                               names_from = c("species_display_name","sex_name"), 
                               values_from = "num_count")
```


# Calculations


## Abundance

**getAbundance(...)**

*Description*

getAbundance(...) uses any amount of arthro collections data to calculate the abundance for the specified parameters. The function calculates using the methods of the Gateway Abundance calculator.


*Usage*

getAbundance(collections,interval, species_list = NULL, trap_list = NULL, species_seperate = FALSE)

*Arguments*

- collections: Collections data retrieved from getArthroCollections(...) 
- interval: Calculation interval for abundance, accepts "collection_date","Biweek","Week", and "Month.
- species_list: Species filter for calculating abundance. Species_display_name is the accepted notation. To see a list of species present in your data run unique(collections$species_display_name). If species is unspecified, the default NULL will return data for all species in data.
- trap_list: Trap filter for calculating abundance. Trap_acronym is the is the accepted notation. Run unique(collections$trap_acronym) to see trap types present in your data. If trap_list is unspecified, the default NULL will return data for all trap types.
- species_seperate: Should the species in species_list have abundance calculated separately? Setting to FALSE calculates the combined abundance. The same result can be performed by calculating on one species at the time.


```{r}
getAbundance(collections,
             interval = "Biweek",
             species_list = c("Cx tarsalis", "Cx pipiens"),
             trap_list = "CO2", 
             species_seperate = FALSE)

```



## Abundance Anomaly (comparison to 5 year average)

**getAbundanceAnomaly()**

*Description*

getAbundanceAnomaly(..) requires at least five years prior to the target_year of arthro collections data to calculate for the specified parameters. The function uses the methods of the Gateway Abundance Anomaly calculator, and will not work if there is fewer than five years of data present.  


*Usage*

getAbundanceAnomaly(collections,interval,target_year, species_list = NULL, trap_list = NULL, species_seperate = FALSE)

*Arguments*

- collections: Collections data retrieved from getArthroCollections(...) 
- interval: Calculation interval for abundance, accepts "collection_date","Biweek","Week", and "Month.
- target_year: Year to calculate analysis on. Collections data must have a year range of at least (target_year - 5, target_year).
- species_list: Species filter for calculating abundance. Species_display_name is the accepted notation. To see a list of species present in your data run unique(collections$species_display_name). If species is unspecified, the default NULL will return data for all species in data.
- trap_list: Trap filter for calculating abundance. Trap_acronym is the is the accepted notation. Run unique(collections$trap_acronym) to see trap types present in your data. If trap_list is unspecified, the default NULL will return data for all trap types.
- species_seperate: Should the species in species_list have abundance calculated separately? Setting to FALSE calculates the combined abundance. The same result can be performed by calculating on one species at the time.


```{r}
collections_18_23 = getArthroCollections(2018,2023, 55)

getAbundanceAnomaly(collections_18_23,
                    interval = "Biweek",
                    target_year = 2023,
                    species_list = c("Cx tarsalis", "Cx pipiens"),
                    trap_list = "CO2",
                    species_seperate = FALSE) 
```

## Infection Rate

**getInfectionRate()**

*Description*

getInfectionRate(..) requires at least five years prior to the target_year of arthro collections data to calculate for the specified parameters. The function uses the methods of the Gateway Abundance Anomaly calculator, and will not work if there is fewer than five years of data present.  


*Usage*

getInfectionRate(pools,interval, target_year, target_disease,pt_estimate, species_list = c(NULL), trap_list = c(NULL))

*Arguments*

- pools: Pools data retrieved from getPools(...) 
- interval: Calculation interval for abundance, accepts "collection_date","Biweek","Week", and "Month.
- target_year: Year to calculate infection rate for. This year must be present in the data.
- target_disease: The disease to calculate infection rate for--i.e. "WNV". Disease acronyms are the accepted input. To see a list of disease acronyms, run unique(pools$target_acronym).
- pt_estimate: The estimation type for infection rate. Options include: "mle","bc-"mle", "mir."
- species_list: Species filter for calculating abundance. Species_display_name is the accepted notation. To see a list of species present in your data run unique(pools$species_display_name). If species is unspecified, the default NULL will return data for all species in data.
- trap_list: Trap filter for calculating abundance. Trap_acronym is the is the accepted notation. Run unique(pools$trap_acronym) to see trap types present in your data. If trap_list is unspecified, the default NULL will return data for all trap types.



```{r}
IR = getInfectionRate(pools, 
                      interval = "Week",
                      target_year = 2023,
                      target_disease = "WNV",
                      pt_estimate = "mle", 
                      species_list = c("Cx pipiens"),
                      trap_list = c("CO2","GRVD") )
IR
```

## Vector Index


**getVectorIndex()**

*Description*

getVectorIndex()(..) requires at least five years prior to the target_year of arthro collections data to calculate for the specified parameters. The function uses the methods of the Gateway Abundance Anomaly calculator, and will not work if there is fewer than five years of data present.  


*Usage*

getVectorIndex(collections, pools, interval,
                           target_year,
                           target_disease,pt_estimate,
                           species_list=NULL,trap_list =  NULL)

*Arguments*
- collections: collections data retrieved from getCollections(...)
- pools: Pools data retrieved from getPools(...) 

**Note: Years from pools and collections data must match**

- interval: Calculation interval for abundance, accepts "collection_date","Biweek","Week", and "Month.
- target_year: Year to calculate infection rate for. This year must be present in the data.
- target_disease: The disease to calculate infection rate. Disease acronyms are the accepted input. To see a list of disease acronyms, run unique(pools$target_acronym).

- pt_estimate: The estimation type for infection rate. Options include: "mle","bc-"mle", "mir."
- species_list: Species filter for calculating abundance. Species_display_name is the accepted notation. To see a list of species present in your data run unique(pools$species_display_name). If species is unspecified, the default NULL will return data for all species in data.
- trap_list: Trap filter for calculating abundance. Trap_acronym is the is the accepted notation. Run unique(pools$trap_acronym) to see trap types present in your data. If trap_list is unspecified, the default NULL will return data for all trap types.


```{r}

pools=getPools(2023,2023,55)
collections= getArthroCollections(2023,2023,55)

getVectorIndex(collections, pools, interval = "Biweek",
                           2023,
                           target_disease = "WNV", pt_estimate = "bc-mle",
                           species_list=c("Cx tarsalis"), 
                           
                           trap_list =  c("CO2"))

```

# Tables

**getPoolsComparisionTable()**

*Description*

getPoolsComparisionTable() produces a frequency table for positive and negative pools counts by year and species. The more years present in the data, the larger the table.

*Usage*

getPoolsComparisionTable(pools,target_disease, species_seperate=F)

*Arguments*

- pools: Pools data retrieved from getPools(...) 
- target_disease: The disease to calculate infection rate for--i.e. "WNV". Disease acronyms are the accepted input. To see a list of disease acronyms, run unique(pools$target_acronym).
- species_seperate: Should the pools comparison be split by species of each pool. Default is FALSE.

```{r}
getPoolsComparisionTable(pools, "WNV", species_seperate = T)
```


## Styling Dataframes with kable

Professional looking tables can be produced using the kable and kableExtra packages.

```{r}
AbAnOutput = getAbundance(collections,
                    interval = "Biweek",
                 
                    species_list = c("Cx tarsalis", "Cx pipiens"),
                    trap_list = "CO2",
                    species_seperate = FALSE) 
head(AbAnOutput)

#As a kable table where column names, font_size, type and much more can be customized

AbAnOutput %>% 
  kbl(col.names = c("Disease Year", "Biweek", "Count","Trap Events", "Abundance")) %>%
  kable_styling(bootstrap_options = "striped",
                font_size = 14,
                latex_options="scale_down")%>%  
  footnote(general = "Table X: Combined biweekly Abundance Calculation for Cx. tarsalis, pipiens in CO2 traps", general_title = "")


```
## Data using datatables

Interactive html only tables can be produced using the DT package. DT tables allow for sorting and filtering with in a webpage. These are ideal for viewing data but are not compatable with pdf or word formats. 

```{r}
#AbAnOutput %>% 
  #datatable(colnames =  c("Disease Year", "Biweek", "Count","Trap Events", "Abundance"))
```




# Charts and Graphs

Ggplot is a easy to use plotting library in R. Gplot syntax consists of creating a ggplot object with a dataframe and adding subsequent arguments to that object. Aesthetics (aes) in ggplot represents the data mapping aspect of the plot. A simple example using collections is shown below.



```{r}
#creates a month column and translates numerics
collections$month = as.factor(month(collections$collection_date))
collections_sums = collections %>% 
  group_by(month, species_display_name) %>%
  summarise(sum_count = sum(num_count, na.rm=T))

#ggplot with dots a values for each species
ggplot(data=collections_sums,
       aes(x = month, y = sum_count, color = species_display_name))+
  geom_point()

#bar chart 
ggplot(data=collections_sums,
       aes(x = month, y = sum_count, fill = species_display_name))+
  geom_bar(stat="identity")


#adding labels
ggplot(data=collections_sums,
       aes(x = month, y = sum_count, fill = species_display_name))+
  geom_bar(stat="identity") +
  labs(title = "Mosquito Counts by Month and Species",x = "Month",
       y = "Sum of Mosquitoes",
       fill = "Species")
```

When plotting with libraries in R, it is easiest when the data is prepared in long form. Most calculator outputs from our functions are in wide form. The following wrapper functions help process and plot this data. 

**ProcessAbunAnom()**

*Description*

ProcessAbunAnom() processes the output returned from getAbundanceAnomaly() into a long form suitable for plotting in ggplot.

*Usage*

ProcessAbunAnom(AbAnomOutput)

*Arguments*

- AbAnomOutput: Output from returned getAbundanceAnomaly()

```{r}

AbAnOut = getAbundanceAnomaly(collections_18_23,
                              interval = "Biweek",
                              target_year = 2023, 
                              species_list = c("Cx tarsalis", "Cx pipiens"),
                              species_seperate = TRUE) #species_seperate set to true will allow for us to facet wrap along species


AbAnOut_L = ProcessAbunAnom(AbAnOut)

#Example using ggplot
AbAnOut_L %>%  filter(Abundance_Type %in% c("2023_Abundance",
                                            "Five_Year_Avg"))%>%  
  ggplot(aes(x=Biweek,
             y= Abundance_Calculation,
             color = Abundance_Type)) +
  geom_point()+ 
  geom_line() + 
  facet_wrap(~species_display_name)+
  labs(title="2023 Abundance Anomaly",y = "")

```

**plotInfectionRate()**

*Description*

plotInfectionRate() plots the output returned from getInfectionRate() with confidence intervals using ggplot

*Usage*

plotInfectionRate(InfRtOutput)

*Arguments*

- InfRtOutput: Output from returned getInfectionRate()

```{r}
IR = getInfectionRate(pools, 
                      interval = "Week", 
                      target_year = 2023, 
                      target_disease = "WNV", 
                      pt_estimate = "mle",
                      species_list = c("Cx pipiens"),
                      trap_list = c("CO2","GRVD") )

plotInfectionRate(InfRtOutput = IR)

```


# Additional Charting Examples

We can highlight rows and columns, add headers, and customize footnotes. For more information please [Click Here](https://cran.r-project.org/web/packages/kableExtra/vignettes/awesome_table_in_html.html#Grouped_Columns__Rows) 

```{r}
collections= getArthroCollections(2021,2023,55)

table(collections$trap_acronym,collections$surv_year)%>% 
  kbl(align = "c") %>%
    kable_paper(full_width = F,
                html_font="arial",
                lightable_options = "striped",
                ) %>% 
  add_header_above(c("Trap Type", "Years" = 3)) %>%
  footnote(general = "Table X: Traps deployed by year", general_title = "") %>%
  row_spec(c(3,9,10), background = "yellow")%>%
  column_spec(c(4), background = "orange")
```

